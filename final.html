<!DOCTYPE html>
<html>
    <head>
        <style>
            #the-canvas { border: 1px solid darkblue; }
            #user-matrix input { width: 64px; font-size: 24px; }
        </style>
    </head>

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
        <script src = "lib.js"></script>
        <script src = "vector.js"></script>
        <script src = "matrix.js"></script>
        <script src = "normal_mesh.js"></script>
        <script src = "controls.js"></script>
        <script src = "cam.js"></script>
        <script src = "lit_material.js"></script>
        <script src = "light.js"></script>
        <script src = "node.js"></script>
        <script src = "render_mesh.js"></script>
        <script>
            //Helpers

            // Easily creates a box for the renderer loop, with coords, scale, and material in one line
            function add_box(parent, x, y, z, sx, sy, sz, material) {
                const mesh = NormalMesh.box(gl, lit_program, 1, 1, 1, material);
                const node = parent.add_child(mesh);
                node.position.x = x;
                node.position.y = y;
                node.position.z = z;
                node.scale.x = sx;
                node.scale.y = sy;
                node.scale.z = sz;
                return node;
            }

            // Easily creates a sideways cylinder for the cart wheels
            function add_wheel(parent, x, y, z, radius, width, material, axis) {
                const mesh = NormalMesh.cylinder(gl, lit_program, radius, width, 32, material, axis);
                const node = parent.add_child(mesh);

                node.isWheel = true;

                node.scale.x = 0.1;
                node.scale.y = 0.1;
                node.scale.z = 0.1;
                node.position.x = x;
                node.position.y = y;
                node.position.z = z;

                return node;
            }

            function add_torch(parent, x, y, z, material) {
                const mesh = NormalMesh.torch(gl, lit_program, 1, 1, 1, material);
                const node = parent.add_child(mesh);
                node.position.x = x;
                node.position.y = y;
                node.position.z = z + .45;
                node.scale.x = .1;
                node.scale.y = .5;
                node.scale.z = .1;
                node.pitch = 0.45;
                return node;
            }
        </script>
        <script>
            let canvas = document.getElementById( 'the-canvas' );
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext( 'webgl2' );

            const GOURAUD_VERTEX_SHADER =
            `   #version 300 es
                precision mediump float;

                uniform mat4 projection;
                uniform mat4 modelview;
                uniform mat4 model;
                uniform mat4 view;
                uniform vec3 viewer_loc;

                uniform vec3 sun_dir;
                uniform vec3 sun_color;

                uniform vec3 light1_loc;
                uniform vec3 light1_color;
                uniform vec3 light2_loc;
                uniform vec3 light2_color;

                const float light_attenuation_k = 0.01;
                const float light_attenuation_l = 0.1;
                const float light_attenuation_q = 0.00; /* no quadratic term for now */

                uniform float mat_ambient;
                uniform float mat_diffuse;
                uniform float mat_specular;
                uniform float mat_shininess;

                in vec3 coordinates;
                in vec4 color;
                in vec2 uv;
                in vec3 surf_normal;

                out vec4 v_color;
                out vec2 v_uv;

                vec3 diff_color(
                    vec3 normal,
                    vec3 light_dir,
                    vec3 light_color,
                    float mat_diffuse
                ) {
                    return mat_diffuse * light_color * max( dot( normal, light_dir ), 0.0 );
                }

                vec3 spec_color(
                    vec3 normal,
                    vec3 light_dir,
                    vec3 eye_dir,
                    vec3 light_color,
                    float mat_specular,
                    float mat_shiniess
                ) {
                    float cos_light_surf_normal = dot( normal, light_dir );

                    if( cos_light_surf_normal <= 0.0 ) {
                        return vec3( 0.0, 0.0, 0.0 );
                    }

                    vec3 light_reflection =
                        2.0 * cos_light_surf_normal * normal - light_dir;

                    return
                        pow(
                            max( dot( light_reflection, normalize( eye_dir ) ), 0.0  ),
                            mat_shininess
                        ) * light_color * mat_specular;
                }

                float attenuation( vec3 vector_to_light ) {
                    float light_dist = length( vector_to_light );
                    float light_atten = 1.0 / (
                        light_attenuation_k +
                        light_attenuation_l * light_dist +
                        light_attenuation_q * light_dist * light_dist
                    );

                    return light_atten;
                }

                void main( void ) {
                    vec3 normal_tx = normalize( mat3( model ) * surf_normal );
                    vec3 coords_tx = ( model * vec4( coordinates, 1.0 ) ).xyz;

                    gl_Position = projection * modelview * vec4( coordinates, 1.0 );
                    vec3 eye_dir = normalize( viewer_loc - coords_tx );

                    vec4 ambient_color = vec4( mat_ambient, mat_ambient, mat_ambient, 1.0 );

                    // vec3 sun_dir_tx =
                    float cos_sun_dir_surf_normal = dot( sun_dir, normal_tx );
                    vec3 sun_diffuse_color = diff_color( normal_tx, sun_dir, sun_color, mat_diffuse );

                    vec3 sun_spec_color =
                        spec_color( normal_tx, sun_dir, eye_dir, sun_color, mat_specular, mat_shininess );

                    vec4 color_from_sun = vec4( sun_diffuse_color + sun_spec_color, 1.0 );

                    vec3 vector_to_light1 = light1_loc - coords_tx;
                    vec3 light1_dir = normalize( vector_to_light1 );
                    float light1_atten = attenuation( vector_to_light1 );

                    vec3 light1_diffuse_color = diff_color(
                        normal_tx, light1_dir, light1_color, mat_diffuse);
                    vec3 light1_spec_color = spec_color(
                        normal_tx, light1_dir, eye_dir, light1_color, mat_specular, mat_shininess );
                    vec4 color_from_light1 = vec4(
                            ( light1_diffuse_color + light1_spec_color ) * light1_atten, 1.0 );

                    vec3 vector_to_light2 = light2_loc - coords_tx;
                    vec3 light2_dir = normalize( vector_to_light2 );
                    float light2_atten = attenuation( vector_to_light2 );

                    vec3 light2_diffuse_color = diff_color(
                        normal_tx, light2_dir, light2_color, mat_diffuse);
                    vec3 light2_spec_color = spec_color(
                        normal_tx, light2_dir, eye_dir, light2_color, mat_specular, mat_shininess );
                    vec4 color_from_light2 = vec4(
                            ( light2_diffuse_color + light2_spec_color ) * light2_atten, 1.0 );

                    /* multiply color by 0 to remove it. try changing the 0 to a small number like .2
                    and the 1 to the complement of that number (1 - .2 = .8) to see how color blending works.*/
                    v_color =
                        ( 0.0 * color ) +
                        ( 1.0 * (
                            ambient_color +
                            color_from_sun +
                            color_from_light1 +
                            color_from_light2
                        ) );
                    v_uv = uv;
                }
            `;

            const GOURAUD_FRAGMENT_SHADER =
            `   #version 300 es
                precision mediump float;

                in vec4 v_color;
                in vec2 v_uv;

                out vec4 f_color;

                uniform sampler2D tex_0;

                void main( void ) {
                    f_color = v_color * texture( tex_0, v_uv );

                    /* we can test depth values with this.
                    f_color = vec4(vec3(gl_FragCoord.z), 1.0); */
                }
            `;

            let lit_program =
                create_compile_and_link_program(
                    gl,
                    /*PHONG_VERTEX_SHADER,*/ GOURAUD_VERTEX_SHADER,
                    /*PHONG_FRAGMENT_SHADER,*/ GOURAUD_FRAGMENT_SHADER
                );

            gl.useProgram( lit_program );

            set_render_params( gl );

            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000.0 / DESIRED_TICK_RATE;

            const ROTATION_SPEED = 0.6;
            const ROTATION_SPEED_PER_FRAME = ROTATION_SPEED / DESIRED_TICK_RATE;

            const FLY_SPEED = 10;    // units per second
            const FLY_SPEED_PER_FRAME = FLY_SPEED / DESIRED_TICK_RATE;

            let keys = Keys.start_listening();
            let cam = new Camera();
            cam.translate( 0, 0, -10 );

            let minecart = new LitMaterial( gl, 'tex/minecart_side.png', gl.LINEAR, 0.25, 1, 2, 5 );
            let minecart_short = new LitMaterial( gl, 'tex/minecart_side2.png', gl.LINEAR, 0.25, 1, 2, 5 );
            let metal = new LitMaterial( gl, 'tex/metal.png', gl.LINEAR, 0.25, 1, 2, 4 );
            let grass = new LitMaterial( gl, 'tex/grass_lawn_seamless.png', gl.LINEAR, 0.2, 0.8, 0.05, 1.0 );
            let oak = new LitMaterial( gl, 'tex/oak_planks.png', gl.LINEAR, 0.25, 0.75, 0, 2 );
            let rail = new LitMaterial( gl, 'tex/stone_rail.png', gl.LINEAR, 0.25, 1, 2, 4 );
            let torch = new LitMaterial( gl, 'tex/torch.png', gl.LINEAR, 0.25, 1, 2, 4 );

            // base floor
            let floorMesh = NormalMesh.box(gl, lit_program, 1, 1, 1, grass);

            //let mesh1_data = NormalMesh.uv_sphere( gl, lit_program, 1, 16, oak );
            let sceneRoot = new Node();

            let floorNode = sceneRoot.add_child(floorMesh);
            floorNode.scale.x = 50;
            floorNode.scale.y = 0.05;
            floorNode.scale.z = 50;
            floorNode.position.y = -0.53;

            // WORLDBUILDING
            // House box
            for (let x = 6; x <= 10; x++) {
                for (let y = 0; y <= 2; y++) {
                    for (let z = 3; z <= 8; z++) {
                        if ((x === 9 && y < 2 && z === 3) || ((z !== 3 && z !== 8) && (x !== 6 && x !== 10)))
                            continue;
                        add_box(sceneRoot, x, y, z, 1, 1, 1, oak);
                    }
                }
            }

            // House roof
            for (let z = 4; z <= 7; z++) {
                for (let x = 7; x <= 9; x++) {
                    let y = 3;
                    if (x === 8 && (z === 5 || z === 6))
                        y += 1;
                    add_box(sceneRoot, x, y, z, 1, 1, 1, oak);
                }
            }

            // Rails
            for (let z = 0; z <= 10; z++)
                add_box(sceneRoot, -1, -1, z, 1, 1, 1, rail);

            add_box(sceneRoot, -1, 0, -1, 1, 1, 1, oak);
            add_box(sceneRoot, -1, 0, 11, 1, 1, 1, oak);

            //Cart
            let cartRoot = sceneRoot.add_child(null);
            cartRoot.position.x = -1;
            cartRoot.position.z = 0.1;

            const CART_WALL_WIDTH = 0.95;
            const CART_WALL_HEIGHT = 0.8;
            const CART_WALL_LENGTH = 1.2;
            const CART_WALL_THICKNESS = 0.05;

            let cartWallMesh = NormalMesh.box( gl, lit_program, 1, 1, 1, minecart);
            let shortCartWallMesh = NormalMesh.box( gl, lit_program, 1, 1, 1, minecart_short);

            //Bottom
            let bottomCartWallNode = cartRoot.add_child(cartWallMesh);
            bottomCartWallNode.scale.x = CART_WALL_WIDTH;
            bottomCartWallNode.scale.y = CART_WALL_THICKNESS;
            bottomCartWallNode.scale.z = CART_WALL_LENGTH;
            bottomCartWallNode.position.y = -0.4;

            //Long sides
            let leftCartWallNode = cartRoot.add_child(cartWallMesh);
            leftCartWallNode.scale.x = CART_WALL_THICKNESS;
            leftCartWallNode.scale.y = CART_WALL_HEIGHT;
            leftCartWallNode.scale.z = CART_WALL_LENGTH;
            leftCartWallNode.position.x = -CART_WALL_WIDTH/2;

            let rightCartWallNode = cartRoot.add_child(cartWallMesh);
            rightCartWallNode.scale.x = CART_WALL_THICKNESS;
            rightCartWallNode.scale.y = CART_WALL_HEIGHT;
            rightCartWallNode.scale.z = CART_WALL_LENGTH;
            rightCartWallNode.position.x = CART_WALL_WIDTH/2;

            //Short sides
            let backCartWallNode = cartRoot.add_child(shortCartWallMesh);
            backCartWallNode.scale.x = CART_WALL_WIDTH;
            backCartWallNode.scale.y = CART_WALL_HEIGHT;
            backCartWallNode.scale.z = CART_WALL_THICKNESS;
            backCartWallNode.position.z = -CART_WALL_LENGTH/2;

            let frontCartWallNode = cartRoot.add_child(shortCartWallMesh);
            frontCartWallNode.scale.x = CART_WALL_WIDTH;
            frontCartWallNode.scale.y = CART_WALL_HEIGHT;
            frontCartWallNode.scale.z = CART_WALL_THICKNESS;
            frontCartWallNode.position.z = CART_WALL_LENGTH/2;

            add_wheel(cartRoot, (CART_WALL_WIDTH/2) + (CART_WALL_THICKNESS/2), -0.4,  (CART_WALL_LENGTH/2) - (CART_WALL_THICKNESS*4), 1, 0.25, metal, "x");   //fr
            add_wheel(cartRoot, (-CART_WALL_WIDTH/2) - (CART_WALL_THICKNESS/2), -0.4,  (CART_WALL_LENGTH/2) - (CART_WALL_THICKNESS*4), 1, 0.25, metal, "x");   //fl
            add_wheel(cartRoot, (CART_WALL_WIDTH/2) + (CART_WALL_THICKNESS/2), -0.4, (-CART_WALL_LENGTH/2) + (CART_WALL_THICKNESS*4), 1, 0.25, metal, "x");   //br
            add_wheel(cartRoot, (-CART_WALL_WIDTH/2) - (CART_WALL_THICKNESS/2), -0.4, (-CART_WALL_LENGTH/2) + (CART_WALL_THICKNESS*4), 1, 0.25, metal, "x");   //bl

            add_torch(sceneRoot, 8, 1, 2, torch)
            add_torch(sceneRoot, 10, 1, 2, torch);
            let light1 = new Light( 8, 1.5, 2.425, 0.5, 0.375, 0.075, 1 );
            let light2 = new Light( 10, 1.5, 2.425, 0.5, 0.375, 0.075, 2 );

            let projection = Mat4.perspective_fovx( 0.125, 4 / 3, 0.125, 1024 );
            let current_program = lit_program;

            let last_update = performance.now();
            let first_frame = performance.now();
            function render( now ) {
                last_update = now;
                requestAnimationFrame( render );
                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

                // GENERATE RENDER JOBS
                const renderJobs = [];
                const identityMatrix = new Mat4();
                generate_render_jobs(identityMatrix, sceneRoot, renderJobs);

                // UNIFORM SETUP
                let view = cam.get_view_matrix();
                set_uniform_matrix4( gl, current_program, 'projection', projection.data );
                set_uniform_matrix4( gl, current_program, 'view', view.data );
                set_uniform_vec3( gl, current_program, 'viewer_loc', cam.x, cam.y, cam.z );

                // ADD LIGHTS
                let seconds = (now - first_frame) / 1000;
                let dayCycleLengthSeconds = 60;
                let angle = (seconds / dayCycleLengthSeconds) * Math.PI * 2.0;
                let sun_dir = ( new Vec4( -Math.cos(angle), Math.sin(angle), 0.0, 0.0 ) ).norm();
                let sun = new Light( sun_dir.x, sun_dir.y, sun_dir.z, 1.0, 0.95, 0.85, 0 );

                sun.bind( gl, current_program, view );
                light1.bind( gl, current_program, view );
                light2.bind( gl, current_program, view );

                // EXECUTE RENDER JOBS
                for (const job of renderJobs) {
                    const model = job.matrix;
                    const modelview = view.mul(model);

                    set_uniform_matrix4( gl, current_program, 'modelview', modelview.data );
                    set_uniform_matrix4( gl, current_program, 'model', model.data );

                    job.mesh.render( gl );
                }
            }

            const KEYMAP = {
                'KeyW': function() { cam.move_in_direction( 0, 0, FLY_SPEED_PER_FRAME ); },
                'KeyS': function() { cam.move_in_direction( 0, 0, -FLY_SPEED_PER_FRAME ); },
                'KeyA': function() { cam.move_in_direction( -FLY_SPEED_PER_FRAME, 0, 0 ); },
                'KeyD': function() { cam.move_in_direction( FLY_SPEED_PER_FRAME, 0, 0 ); },
                'Space': function() { cam.translate( 0, FLY_SPEED_PER_FRAME, 0 ); },
                'KeyC': function() { cam.translate( 0, -FLY_SPEED_PER_FRAME, 0 ); },
                'ShiftLeft': function() { cam.translate( 0, -FLY_SPEED_PER_FRAME, 0 ); },
                'KeyQ': function() { cam.add_roll( -ROTATION_SPEED_PER_FRAME ); },
                'KeyE': function() { cam.add_roll( ROTATION_SPEED_PER_FRAME ); },
                'ArrowLeft': function() { cam.add_yaw( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowRight': function() { cam.add_yaw( ROTATION_SPEED_PER_FRAME ); },
                'ArrowUp': function() { cam.add_pitch( ROTATION_SPEED_PER_FRAME ); },
                'ArrowDown': function() { cam.add_pitch( -ROTATION_SPEED_PER_FRAME ); },
            };

            let cartSpeed = 0.1;
            let cartForward = true;
            const cartMinZ = 0.1;
            const cartMaxZ = 9.9;

            function update() {
                let keys_down = keys.keys_down_list();

                for( const key of keys_down ) {
                   let bound_function = KEYMAP[ key ];

                   if( bound_function ) {
                       bound_function();
                   }
                }

                cartRoot.position.z += cartSpeed;

                // Make sure the direction flips when we reach an end
                if (cartRoot.position.z > cartMaxZ) {
                    cartRoot.position.z = cartMaxZ;
                    cartSpeed *= -1;
                    cartForward = false;
                }
                if (cartRoot.position.z < cartMinZ) {
                    cartRoot.position.z = cartMinZ;
                    cartSpeed *= -1;
                    cartForward = true;
                }

                // Spin the wheels
                for (let wheel of cartRoot.children) {
                    if (wheel.isWheel) {
                        if (cartForward) { wheel.pitch -= 0.05; }
                        else if (!cartForward) { wheel.pitch += 0.05; }
                    }
                }


                return;
            }

            requestAnimationFrame( render );
            setInterval( update, DESIRED_MSPT );
        </script>
    </body>
</html>
